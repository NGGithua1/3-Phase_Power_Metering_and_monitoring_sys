#include "main.h"
#include "ssd1306.h"// Assume an SSD1306 driver is available
#include <stdio.h>

#define ADC_MAX 4096.0
#define VREF 3.3

// Calibration factors for voltage divider (example: divider ratio = 11)
#define VOLTAGE_SCALE 11.0

// ACS712 calibration for 5A variant: sensitivity 185 mV/A, with mid offset ~1.65V (assuming 3.3V system may require adjustment)
#define CURRENT_OFFSET (VREF/2)  // 1.65V (if using 3.3V reference)
#define CURRENT_SENSITIVITY 0.185  // V per A

ADC_HandleTypeDef hadc1;
I2C_HandleTypeDef hi2c1;

uint32_t adcValues[6];

void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
static void MX_I2C1_Init(void);

float readVoltage(uint32_t adcValue) {
    float voltage = (adcValue * (VREF / ADC_MAX)) * VOLTAGE_SCALE;
    return voltage;
}

float readCurrent(uint32_t adcValue) {
    float voltage = adcValue * (VREF / ADC_MAX);
    // Subtract offset and calculate current (A)
    float current = (voltage - CURRENT_OFFSET) / CURRENT_SENSITIVITY;
    return current;
}

void updateDisplay(float vA, float iA, float pA,
                   float vB, float iB, float pB,
                   float vC, float iC, float pC) {
    char buffer[32];
    SSD1306_Clear();
    sprintf(buffer, "A:%.1fV %.1fA", vA, iA);
    SSD1306_GotoXY(0, 0);
    SSD1306_Puts(buffer, &Font_7x10, 1);
    
    sprintf(buffer, "PA:%.1fW", pA);
    SSD1306_GotoXY(0, 12);
    SSD1306_Puts(buffer, &Font_7x10, 1);
    
    sprintf(buffer, "B:%.1fV %.1fA", vB, iB);
    SSD1306_GotoXY(0, 24);
    SSD1306_Puts(buffer, &Font_7x10, 1);
    
    sprintf(buffer, "PB:%.1fW", pB);
    SSD1306_GotoXY(0, 36);
    SSD1306_Puts(buffer, &Font_7x10, 1);
    
    sprintf(buffer, "C:%.1fV %.1fA", vC, iC);
    SSD1306_GotoXY(0, 48);
    SSD1306_Puts(buffer, &Font_7x10, 1);
    
    sprintf(buffer, "PC:%.1fW", pC);
    SSD1306_GotoXY(0, 60);
    SSD1306_Puts(buffer, &Font_7x10, 1);
    
    SSD1306_UpdateScreen();
}

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_ADC1_Init();
    MX_I2C1_Init();
    
    // Initialize the OLED display
    SSD1306_Init();
    
    while (1)
    {
        // Start ADC conversion for all 6 channels (3 voltage sensors: PA0, PA1, PA2 and 3 current sensors: PA3, PA4, PA5)
        HAL_ADC_Start(&hadc1);
        for (int i = 0; i < 6; i++) {
            HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
            adcValues[i] = HAL_ADC_GetValue(&hadc1);
        }
        HAL_ADC_Stop(&hadc1);
        
        // Calculate for Phase A (Voltage on PA0, Current on PA3)
        float vA = readVoltage(adcValues[0]);
        float iA = readCurrent(adcValues[3]);
        float pA = vA * iA;
        
        // Calculate for Phase B (Voltage on PA1, Current on PA4)
        float vB = readVoltage(adcValues[1]);
        float iB = readCurrent(adcValues[4]);
        float pB = vB * iB;
        
        // Calculate for Phase C (Voltage on PA2, Current on PA5)
        float vC = readVoltage(adcValues[2]);
        float iC = readCurrent(adcValues[5]);
        float pC = vC * iC;
        
        updateDisplay(vA, iA, pA, vB, iB, pB, vC, iC, pC);
        
        // Relay control logic (example: if power exceeds a threshold, disable output)
        // Assume threshold values and GPIO control are implemented as needed.
        HAL_Delay(1000);
    }
}
